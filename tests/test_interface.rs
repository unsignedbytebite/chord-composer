extern crate chord_composer;

use chord_composer::{
  performance::performance_engine::PerformanceState,
  theory::composition::{Composition, Pattern, PatternEvent},
};
use music_timer::{music_time::MusicTime, time_signature::TimeSignature};

struct MyState {
  callback_calls: u16,
  current_time: MusicTime,
}

impl PerformanceState for MyState {
  fn on_ready(&mut self, composition: &Composition) {
    self.callback_calls += 1;
    assert_eq!(composition.get_name(), "middle_c");
    println!("on_ready");
  }
  fn on_beat_interval_change(&mut self, current_time: &MusicTime) {
    self.callback_calls += 1;
    self.current_time = current_time.clone();
    println!("on_beat_interval_change: {:?}", current_time);
  }
  fn on_beat_change(&mut self, current_time: &MusicTime) {
    self.callback_calls += 1;
    println!("on_beat_change: {:?}", current_time);
  }
  fn on_bar_change(&mut self, current_time: &MusicTime) {
    self.callback_calls += 1;
    println!("on_bar_change: {:?}", current_time);
  }
  fn on_event(&mut self, _event: &PatternEvent) {
    self.callback_calls += 1;
    println!("on_event");
  }
  fn on_pattern_playback_begin(&mut self, _pattern: &Pattern) {
    self.callback_calls += 1;
    println!("on_pattern_playback_begin");
  }
  fn on_pattern_playback_end(&mut self, _pattern: &Pattern) {
    self.callback_calls += 1;
    println!("on_pattern_playback_end");
  }
  fn on_completed(&mut self, composition: &Composition) {
    self.callback_calls += 1;
    assert_eq!(composition.get_name(), "middle_c");
    println!("on_completed");
  }
}

#[test]
fn chord_to_string_array() {
  let chords = chord_composer::get_chord_keywords();
  assert_eq!(chords.len(), 73);
  assert_eq!(chords[0], "AUGMENTED = [0, 4, 8]");
}

#[test]
fn export_midi_missing_file() {
  let file = "./tests/no_file.gone";

  assert_eq!(
    chord_composer::export_composition_to_midi(file),
    Err(chord_composer::FailResult::Deserialize)
  );
}

#[test]
fn export_midi_no_patterns() {
  let file = "./tests/export_test_no_patterns.yaml";

  assert_eq!(
    chord_composer::export_composition_to_midi(file),
    Err(chord_composer::FailResult::NoPatterns)
  );
}

#[test]
fn test_export_template() {
  assert_eq!(
    chord_composer::export_template("./tests/test_template_export.yaml"),
    Ok(chord_composer::SuccessResult::ExportTemplate)
  );
}

#[test]
fn export_midi() {
  let file = "./tests/export_test.yaml";

  let files = vec![
    "./tests/bc_000_a/part_a.mid".to_string(),
    "./tests/bc_000_a/part_b.mid".to_string(),
  ];

  assert_eq!(
    chord_composer::export_composition_to_midi(file),
    Ok(chord_composer::SuccessResult::Export(files.clone())),
  );

  use std::fs::File;
  use std::io::prelude::*;

  let file1_bin = vec![
    0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x01, 0xe0, 0x4d, 0x54,
    0x72, 0x6b, 0x00, 0x00, 0x00, 0x13, 0x00, 0xff, 0x51, 0x03, 0x07, 0x27, 0x0e, 0x00, 0xff, 0x58,
    0x04, 0x03, 0x02, 0x08, 0x18, 0x00, 0xff, 0x2f, 0x00, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x01,
    0x07, 0x00, 0xff, 0x03, 0x06, 0x70, 0x61, 0x72, 0x74, 0x5f, 0x61, 0x00, 0x90, 0x32, 0x40, 0x00,
    0x90, 0x36, 0x40, 0x00, 0x90, 0x39, 0x40, 0x00, 0x90, 0x3d, 0x40, 0x87, 0x40, 0x90, 0x32, 0x00,
    0x00, 0x90, 0x36, 0x00, 0x00, 0x90, 0x39, 0x00, 0x00, 0x90, 0x3d, 0x00, 0x00, 0x90, 0x32, 0x40,
    0x00, 0x90, 0x35, 0x40, 0x00, 0x90, 0x3a, 0x40, 0x83, 0x60, 0x90, 0x32, 0x00, 0x00, 0x90, 0x35,
    0x00, 0x00, 0x90, 0x3a, 0x00, 0x00, 0x90, 0x32, 0x40, 0x00, 0x90, 0x36, 0x40, 0x00, 0x90, 0x39,
    0x40, 0x00, 0x90, 0x3d, 0x40, 0x00, 0x90, 0x34, 0x40, 0x87, 0x40, 0x90, 0x32, 0x00, 0x00, 0x90,
    0x36, 0x00, 0x00, 0x90, 0x39, 0x00, 0x00, 0x90, 0x3d, 0x00, 0x00, 0x90, 0x34, 0x00, 0x00, 0x90,
    0x32, 0x40, 0x00, 0x90, 0x35, 0x40, 0x00, 0x90, 0x3a, 0x40, 0x83, 0x60, 0x90, 0x32, 0x00, 0x00,
    0x90, 0x35, 0x00, 0x00, 0x90, 0x3a, 0x00, 0x00, 0x90, 0x35, 0x40, 0x00, 0x90, 0x39, 0x40, 0x00,
    0x90, 0x3c, 0x40, 0x00, 0x90, 0x40, 0x40, 0x83, 0x60, 0x90, 0x35, 0x00, 0x00, 0x90, 0x39, 0x00,
    0x00, 0x90, 0x3c, 0x00, 0x00, 0x90, 0x40, 0x00, 0x00, 0x90, 0x32, 0x40, 0x00, 0x90, 0x35, 0x40,
    0x00, 0x90, 0x3a, 0x40, 0x83, 0x60, 0x90, 0x32, 0x00, 0x00, 0x90, 0x35, 0x00, 0x00, 0x90, 0x3a,
    0x00, 0x83, 0x60, 0x90, 0x2f, 0x40, 0x00, 0x90, 0x33, 0x40, 0x00, 0x90, 0x36, 0x40, 0x00, 0x90,
    0x3a, 0x40, 0x00, 0x90, 0x31, 0x40, 0x83, 0x60, 0x90, 0x2f, 0x00, 0x00, 0x90, 0x33, 0x00, 0x00,
    0x90, 0x36, 0x00, 0x00, 0x90, 0x3a, 0x00, 0x00, 0x90, 0x31, 0x00, 0x00, 0x90, 0x32, 0x40, 0x00,
    0x90, 0x35, 0x40, 0x00, 0x90, 0x3a, 0x40, 0x87, 0x40, 0x90, 0x32, 0x00, 0x00, 0x90, 0x35, 0x00,
    0x00, 0x90, 0x3a, 0x00, 0x00, 0xff, 0x2f, 0x00,
  ];

  let buffer = {
    let mut f = File::open(&files[0]).unwrap();
    let mut buffer = Vec::new();
    f.read_to_end(&mut buffer).unwrap();
    buffer
  };

  assert_eq!(buffer, file1_bin);

  let file2_bin = vec![
    0x4D, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x01, 0xE0, 0x4D, 0x54,
    0x72, 0x6B, 0x00, 0x00, 0x00, 0x13, 0x00, 0xFF, 0x51, 0x03, 0x0D, 0x44, 0xBD, 0x00, 0xFF, 0x58,
    0x04, 0x04, 0x03, 0x08, 0x18, 0x00, 0xFF, 0x2F, 0x00, 0x4D, 0x54, 0x72, 0x6B, 0x00, 0x00, 0x01,
    0x06, 0x00, 0xFF, 0x03, 0x06, 0x70, 0x61, 0x72, 0x74, 0x5F, 0x62, 0x00, 0x90, 0x31, 0x40, 0x00,
    0x90, 0x35, 0x40, 0x00, 0x90, 0x38, 0x40, 0x00, 0x90, 0x3C, 0x40, 0x83, 0x60, 0x90, 0x31, 0x00,
    0x00, 0x90, 0x35, 0x00, 0x00, 0x90, 0x38, 0x00, 0x00, 0x90, 0x3C, 0x00, 0x00, 0x90, 0x31, 0x40,
    0x00, 0x90, 0x34, 0x40, 0x00, 0x90, 0x39, 0x40, 0x8B, 0x20, 0x90, 0x31, 0x00, 0x00, 0x90, 0x34,
    0x00, 0x00, 0x90, 0x39, 0x00, 0x00, 0x90, 0x31, 0x40, 0x00, 0x90, 0x35, 0x40, 0x00, 0x90, 0x38,
    0x40, 0x00, 0x90, 0x3C, 0x40, 0x00, 0x90, 0x33, 0x40, 0x83, 0x60, 0x90, 0x31, 0x00, 0x00, 0x90,
    0x35, 0x00, 0x00, 0x90, 0x38, 0x00, 0x00, 0x90, 0x3C, 0x00, 0x00, 0x90, 0x33, 0x00, 0x00, 0x90,
    0x31, 0x40, 0x00, 0x90, 0x34, 0x40, 0x00, 0x90, 0x39, 0x40, 0x8B, 0x20, 0x90, 0x31, 0x00, 0x00,
    0x90, 0x34, 0x00, 0x00, 0x90, 0x39, 0x00, 0x00, 0x90, 0x34, 0x40, 0x00, 0x90, 0x38, 0x40, 0x00,
    0x90, 0x3B, 0x40, 0x00, 0x90, 0x3F, 0x40, 0x83, 0x60, 0x90, 0x34, 0x00, 0x00, 0x90, 0x38, 0x00,
    0x00, 0x90, 0x3B, 0x00, 0x00, 0x90, 0x3F, 0x00, 0x00, 0x90, 0x31, 0x40, 0x00, 0x90, 0x34, 0x40,
    0x00, 0x90, 0x39, 0x40, 0x8B, 0x20, 0x90, 0x31, 0x00, 0x00, 0x90, 0x34, 0x00, 0x00, 0x90, 0x39,
    0x00, 0x00, 0x90, 0x2E, 0x40, 0x00, 0x90, 0x32, 0x40, 0x00, 0x90, 0x35, 0x40, 0x00, 0x90, 0x39,
    0x40, 0x00, 0x90, 0x30, 0x40, 0x83, 0x60, 0x90, 0x2E, 0x00, 0x00, 0x90, 0x32, 0x00, 0x00, 0x90,
    0x35, 0x00, 0x00, 0x90, 0x39, 0x00, 0x00, 0x90, 0x30, 0x00, 0x00, 0x90, 0x31, 0x40, 0x00, 0x90,
    0x34, 0x40, 0x00, 0x90, 0x39, 0x40, 0x8B, 0x20, 0x90, 0x31, 0x00, 0x00, 0x90, 0x34, 0x00, 0x00,
    0x90, 0x39, 0x00, 0x00, 0xFF, 0x2F, 0x00,
  ];

  let buffer = {
    let mut f = File::open(&files[1]).unwrap();
    let mut buffer = Vec::new();
    f.read_to_end(&mut buffer).unwrap();
    buffer
  };

  assert_eq!(buffer, file2_bin);
}

#[test]
fn test_play_file() {
  let file = "./tests/middle_c.yaml";

  use chord_composer::{
    performance::performance_engine::PerformanceState,
    theory::composition::{Composition, Pattern, PatternEvent},
  };
  use music_timer::music_time::MusicTime;

  let mut my_state = MyState {
    callback_calls: 0,
    current_time: MusicTime::default(),
  };

  assert_eq!(
    chord_composer::play(file, &mut my_state, false, &Vec::new(), &Vec::new()),
    Ok(chord_composer::SuccessResult::Playback)
  );

  assert_eq!(my_state.callback_calls, 33);
  assert_eq!(my_state.current_time, MusicTime::new(1, 3, 8));
}

//TODO: test to interface engine without parsing data

#[test]
fn play_composition_api() {
  let composition = Composition::new_with_patterns(
    "test composition",
    vec![Pattern::new_with_events(
      "pattern A",
      100,
      TimeSignature::default(),
      vec![
        (MusicTime::new(1, 1, 1), vec![0, 4, 7]),
        (MusicTime::new(2, 1, 1), vec![0, 3, 7]),
      ],
    )],
  );

  let mut my_state = MyState {
    callback_calls: 0,
    current_time: MusicTime::default(),
  };

  chord_composer::play(composition, &mut my_state, false, &Vec::new(), &Vec::new());
}

#[test]
fn export_midi_api() {
  assert!(false, "TODO");
}
